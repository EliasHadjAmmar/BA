---
title: "Target for the data"
output: html_document
date: "2023-01-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/GitHub/BA')
library(tidyverse)
library(haven)
```


I want a city-year panel of
- construction activity
- ruling lineage (terr_id)
- ruling lineage's extinction in that year
- cities held by ruling lineage in that year
- controls (capital status, conflict)


## Relational database approach

It seems to me that this kind of works like a relational database. Each city-year observation has non-missing ruling lineage. Each lineage-year observation has non-missing extinction dummy and size.

### Lineage for all city-year observations

This is already in `cities_families.dta`. The lineage is given for every city-year observation.

```{r cities data}
cities <- read_dta('build/input/cities_families_1300_1918.dta')
summary(cities)
view(cities)
```
### Extinction for all lineage-year observations

The file `family_rulers_imputed.dta` is a list of person-level observations. I turn this into a lineage-year panel of rulers in the same way I did for work: filter for non-missing terr_id. 
(This relies on what Matthias told me to do in summer being correct. I should verify my implicit assumptions about the dataset - that non-rulers in `family_rulers_imputed.dta` have missing terr_id, and that the ruler list is therefore a lineage-year panel of rulers.)

Then I can obtain the extinction year of each lineage by filtering for the last ruler in each lineage (max start_reign). This ruler's death_year is the extinction year of the lineage (or where our data ends. In a future iteration of this, I could use the `territories.csv` data to cross-validate.)

### Size for all lineage-year observations

Use number of cities. You can recycle code you wrote in the territories project.

## Merging / joining the relational data

Find out how this works once you have constructed everything.
