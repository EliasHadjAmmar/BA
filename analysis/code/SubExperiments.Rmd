## Stacking sub-experiments

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/GitHub/BA')
library(tidyverse)
library(cowplot)
```

In this file I want to get a feeling for how I can get stackable sub-experiments from the data.

What I learned in Exploration.Rmd (based on 382 extinctions from the ruler data):

- I have almost 500 observations on average for each city.
- **A normal city changes hands 3-4 times throughout its history.**
- **Of these territory changes, 1-2 are due to extinction.**
- **A normal city undergoes around 60 changes in integration.**
- Most cities become drastically more integrated over time.

My process for getting sub-experiments should take an extinction list as input, apply transparent criteria, and return a list of sub-experiments.

### What kind of object is a sub-experiment?

A sub-experiment is a subset of the build, i.e. a city-year data set, so that

- the sub-experiment contains, for each city in it, all years between t-W and t+W, where t is an extinction year.
- no city in the sub-experiment undergoes an extinction (or size diff?) at any time other than t.


### Sketching the code

1. Identify sub-experiments (extinctions with W years of data before/after)
2. Define inclusion criteria to get a data set for each subexp
    - C1: within d all treated cities' only extinction within [t-2W, t+W] is t
    - C2: only units with no extinctions in [t-2W, t+W] are eligible controls
    - C3: only observations from years [t-W, t+W] are included
    Make dummies for each of those conditions
3. Stack the data

### Checking correlation between extinction treatment and count diff

```{r data import}
build <- read_csv("analysis/input/build.csv") %>% 
  select(city_id, year, terr_id, final_full_year, 
        extinction, treatment, extinction_of, count_diff)

```

```{r check extinct vs non-extinct}
# use x = extinction as sanity check (diffs will be 0)

diff_ext <- build %>% 
  mutate(treatment=factor(treatment)) %>% 
  ggplot() + 
  geom_boxplot(aes(x = treatment, y=count_diff)) 

diff_ext_no_outliers <- build %>% 
  mutate(treatment=factor(treatment)) %>% 
  ggplot() + 
  geom_boxplot(aes(x = treatment, y=count_diff), outlier.shape = NA) +
  coord_cartesian(ylim = quantile(build$count_diff, c(0.0026, 0.996), na.rm=TRUE))

diff_ext_big_diffs <- build %>% 
  mutate(treatment=factor(treatment)) %>% 
  filter(abs(count_diff) > 1) %>% 
  ggplot() + 
  geom_boxplot(aes(x = treatment, y=count_diff)) 

diff_ext_big_diffs_zoom <- build %>% 
  mutate(treatment=factor(treatment)) %>% 
  filter(abs(count_diff) > 1) %>% 
  ggplot() + 
  geom_boxplot(aes(x = treatment, y=count_diff), outlier.shape = NA) +
  coord_cartesian(ylim = quantile(build$count_diff, c(0.0026, 0.996), na.rm=TRUE))

plot_grid(diff_ext, diff_ext_no_outliers, diff_ext_big_diffs, diff_ext_big_diffs_zoom,
          labels = c("Full plot", "Zoom", "Diffs >1", "Diffs >1, zoom"))
```

Make this code neater. But you can definitely see that extinctions are correlated with bigger count diffs.

### Implementing stacked sub-experiments

```{r define window size}
W <- 20
```


```{r identify sub-experiments}

extinctions <- read_csv("build/temp/last_rulers.csv") %>% 
  select(terr_id, death_year, family, name) %>% 
  mutate(sub_exp = if_else(
    between(death_year, min(build$year) + W, max(build$year) - W),
    1, 0))

subexp <- extinctions %>% 
  rename(treat_year = death_year) %>% # last full year + 1 = death year = treat year
  filter(sub_exp == 1) %>% 
  select(terr_id, treat_year)

subexp <- subexp %>% 
  mutate(
    lower_inclusion_bound = treat_year - 2*W,
    upper_inclusion_bound = treat_year + W,
    exp_start = treat_year - W,
    exp_end = treat_year + W) 
  
```

```{r get data for each subexp}

# let's pick one subexp to tinker on. let's pick the extinction of A1541.
d <- subexp[subexp$terr_id == "A1541",]

# first we want to get all cities that fall into the inclusion range of d:
inclusion_range <- d$lower_inclusion_bound:d$upper_inclusion_bound
d_cities <- build %>% 
  group_by(city_id) %>% 
  summarise(
    d_dummy = if_else(all(inclusion_range %in% min(year):max(year)), 1, 0)
    ) %>% 
  filter(d_dummy == 1)

  
# does this make sense? all cities with a 1 should have yearly observations
# within the inclusion range.

build %>% 
  semi_join(d_cities, by="city_id") %>% 
  filter(year %in% inclusion_range) %>% 
  ggplot()+
  geom_bar(aes(x=year))

# there is some slight variation but it looks good overall.
# how do I drop cities where not all years are in the data?

build %>% 
  semi_join(d_cities, by="city_id") %>% 
  filter(year %in% inclusion_range) %>% 
  group_by(city_id) %>% 
  filter(n() == 3*W+1) %>% 
  ggplot()+
  geom_bar(aes(x=year))

# this is how it works. But after this I still have to check the other criteria.
```

```{r get data for d}

d_base_data <- build %>% # this is all city-years in the inclusion range
  semi_join(d_cities, by="city_id") %>% 
  filter(year %in% inclusion_range) %>% 
  group_by(city_id) %>% 
  filter(n() == 3*W+1)

d_treat_cities <- d_base_data %>% # this is all cities satisfying:
  group_by(city_id) %>% 
  filter(sum(treatment) == 1) %>% # there must be exactly one treatment
  ungroup() %>% 
  filter(treatment == 1) %>% # d must be that one treatment
  filter(extinction_of == d$terr_id) %>% 
  mutate(d_treat = 1)

d_control_cities <- d_base_data %>% 
  group_by(city_id) %>% 
  filter(sum(treatment) == 0) %>% # there must be no treatment in the inclusion period
  summarise(d_treat = 0)
  
d_sample <- bind_rows(d_treat_cities, d_control_cities)

```

I am worried because count_diff is now 0 for all treatment cities.

```{r check whether it worked}
# check whether the cities actually underwent size diffs
build %>% filter(city_id == 11056 & between(year, 1660, 1670))

# check the sizes of the territories
lineages <- read_csv("analysis/input/lineages.csv")
lineages %>% 
  filter(terr_id %in% c("A1541", "A156") & between(year, 1663, 1667)) %>% 
  select(terr_id, year, final_full_year, extinction, count_cities)
```

This is very reassuring; the territories are actually the same size; A156 had nothing before and took everything A1541 had.

I guess now the next step is to abstract what I learned here into functions. I do this in a different file.
